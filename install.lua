local fs = require("filesystem")
local pkg = { ["/lib/twins/init.lua"]="twins = {} setmetatable(twins, { __index = function(self, index) return twins.sem[index] end }) local event = require(\"event\") local util = require(\"twins.core.util\") local computer = require(\"computer\") local renderDevice = require(\"twins.core.render_device\") twins.container = renderDevice.getDefault() twins.sps = require(\"twins.core.sps\") twins.sem = require(\"twins.core.sem\") local elements_helper = require(\"twins.core.elements_helper\") local graphics_helper = require(\"twins.core.graphics_helper\") twins.sem.scw, twins.sem.sch = twins.container.getResolution() function twins.wake() twins.sem.scw, twins.sem.sch = twins.container.getResolution() end twins.get_element_by_key = twins.sem.get_element_by_key function twins.set_context(context_id, silent) if twins.sem.contexts[context_id] == nil then twins.sem.contexts[context_id] = { document={}, elements={}, named_elements={}, element_templates={}, focus=-1 } end local ctx = twins.sem.contexts[context_id] twins.sem.document = ctx.document twins.sem.elements = ctx.elements twins.sem.named_elements = ctx.named_elements twins.sem.focus = ctx.focus twins.sem.element_templates = ctx.element_templates twins.sem.active_context = context_id end function twins.show_context(context_id) twins.sem.invoke(twins.sem.document, \"onctxinactive\") twins.set_context(context_id) twins.sem.invoke(twins.sem.document, \"onctxactive\") twins.render(true) end twins.set_context(twins.sem.active_context) twins.get_focus = twins.sem.get_focus twins.render = twins.sem.render twins.title = twins.sem.title twins.draw_frame = graphics_helper.draw_frame twins.clear_screen = graphics_helper.clear_screen twins.add_template = elements_helper.add_template local function load_from_file(module_name, load_only) local succ, mod if not load_only then succ, mod = pcall(require, module_name) local err if not succ then succ, mod = pcall(function() local code, err = loadfile(module_name) assert(code, err) return code() end) end else succ, mod = pcall(function() local code, err = loadfile(module_name) assert(code, err) return code() end) end if not mod then error(\"Файл не может быть найден.\") end if type(mod) == \"string\" then error(mod) end return mod end function twins.load_elements(module_name, load_as, load_only) local mod local mod_type = type(module_name) if mod_type == \"string\" then mod = load_from_file(module_name, load_only) elseif mod_type == \"table\" then mod = module_name else error(\"Аргумент типа \" .. mod_type .. \" не поддерживается\") end twins[load_as] = {} for elem_name, elem_content in pairs(mod) do if elem_content.render then local _render = elem_content.render local function wrapped_render(self, no_update) if sem.running then _render(self) end if not no_update then twins.container.render() end end end twins[load_as][elem_name] = function(t) t = t or {} return elements_helper.build_element(t, elem_content) end end end local function touch_listener(e_name, addr, x, y, button) local offx, offy = 0, 0 for k, v in pairs(twins.sem.elements) do local ex, ey, ew, eh = v.getxywh(v) if x-offx >= ex and x-offx < ex + ew and y-offy >= ey and y-offy < ey + eh and v.clickable then if v.visible and twins.sem.focus ~= k then local foc_elem = twins.get_focus() if foc_elem then twins.sem.invoke(foc_elem, \"onfocus\", x-v.x, y-v.y) end twins.sem.focus = k twins.sem.invoke(twins.get_focus(), \"onfocusloss\") end twins.sem.invoke(v, \"onclick\", {x=x, y=y}, {x=x-v.x, y=y-v.y}, button) end end end local function key_down_listener(e_name, addr, letter, key) local focus = twins.get_focus() twins.sem.invoke(twins.sem.document, \"onkeydown\", letter, key) if focus then if focus.visible then twins.sem.invoke(focus, \"onkeydown\", letter, key) end end end local function scroll_listener(e_name, addr, x, y, size) local offx, offy = 0, 0 if twins.container.type == \"tornado_vs\" then offx = twins.container.internal.x offy = twins.container.internal.y end for k, v in pairs(twins.sem.elements) do local ex, ey, ew, eh = v.getxywh(v) if x-offx >= ex and x-offx < ex + ew and y-offy >= ey and y-offy < ey + eh then twins.sem.invoke(v, \"onscroll\", {x=x, y=y}, {x=x-v.x, y=y-v.y}, size) end end end twins.load_elements(\"/lib/twins/core/elem_base.lua\", \"base\", true) function twins.use_macros(container) if type(container) ~= \"table\" then container = _G end function container.group(props) return function(items) props.items = items return twins.base.group(props) end end container.button = twins.base.button container.text = twins.base.text container.input = twins.base.input end local function shutdown_sequence() for ctx_id, ctx in pairs(twins.sem.contexts) do twins.set_context(ctx_id) for k, v in pairs(twins.sem.elements) do twins.sem.invoke(v, \"ondestroy\") twins.sem.elements[k] = nil end twins.sem.element_templates = {} end end local kdid, t_id, scr_id function twins.connect_listeners() kdid = event.listen(\"key_down\", key_down_listener) t_id = event.listen(\"touch\", touch_listener) scr_id = event.listen(\"scroll\", scroll_listener) end function twins.disconnect_listeners() event.cancel(kdid) event.cancel(t_id) event.cancel(scr_id) end function twins.euthanize() twins.running = false computer.pushSignal(\"twins_term\", 1) end function twins.sleep(timeout) local deadline = computer.uptime() + (timeout or 0) repeat local sig = event.pull(deadline - computer.uptime()) until computer.uptime() >= deadline or sig == \"twins_term\" end function twins.main() twins.set_context(1) local init_bg = twins.container.getBackground() local init_fg = twins.container.getForeground() twins.running = true twins.connect_listeners() local succ = xpcall(function() twins.clear_screen() twins.render() while twins.running do twins.sleep(math.huge) if not twins.running then break end end end, function(...) err = debug.traceback(...) end) twins.disconnect_listeners() shutdown_sequence() twins.container.setForeground(init_fg) twins.container.setBackground(init_bg) for k, v in pairs(twins.sem.contexts) do twins.set_context(k) elements_helper.clear_elements() end twins.sem.contexts = {} twins.set_context(1) if not succ then error(err, 3) end end function twins.main_coroutine() twins.set_context(1) local init_bg = twins.container.getBackground() local init_fg = twins.container.getForeground() twins.running = true twins.connect_listeners() local succ, err = xpcall(function() twins.clear_screen() while twins.running do twins.render() coroutine.yield() end end, function(...) err = debug.traceback(...) end) twins.disconnect_listeners() twins.clear_screen(twins.sem.document.destroy_color) shutdown_sequence() twins.container.setForeground(init_fg) twins.container.setBackground(init_bg) for k, v in pairs(twins.sem.contexts) do twins.set_context(k) elements_helper.clear_elements() end twins.sem.contexts = {} twins.set_context(1) if not succ then error(err, 3) end end return twins ",["/lib/twins/core/elem_base.lua"]="local unicode = require \"unicode\" local event = require \"event\" local serialization = require \"serialization\" local elem_base = { button = { x = 1, y = 1, w = 10, h = 3, bgcolor = 0x222222, fgcolor = 0xffffff, text = \"button\", render = function(self) twins.container.setBackground(self.bgcolor) twins.container.setForeground(self.fgcolor) twins.container.fill(self.x, self.y, self.w, self.h, \" \") twins.draw_frame(self) twins.container.set(self.x+self.w/2-unicode.len(self.text)/2, self.y+self.h/2, self.text) end }, text = { x = 1, y = 1, h = 1, text = \"text\", align = \"left\", fgcolor = 0xffffff, bgcolor = 0x000000, render = function(self) twins.container.setForeground(self.fgcolor) twins.container.setBackground(self.bgcolor) if self.align == \"left\" then local text = unicode.sub(tostring(self.text), 1, self.w) text = text .. string.rep(\" \", self.w-unicode.len(text)) twins.container.set(self.x, self.y, text) elseif self.align == \"center\" then local rel_x = math.floor(self.w/2-unicode.len(self.text)/2) local rel_h = math.floor(self.h/2) local left_pad = string.rep(\" \", rel_x - 1) local right_pad = string.rep(\" \", self.w - rel_x - unicode.len(self.text) - 1) local text = left_pad .. self.text .. right_pad twins.container.set(self.x, self.y, text) elseif self.align == \"right\" then local text = unicode.sub(tostring(self.text), 1, self.w) text = string.rep(\" \", self.w-unicode.len(text)) .. text twins.container.set(self.x, self.y, text) end end, oncreate = function(self) self:adjust_width() end, adjust_width = function(self) if not self.w then self.w = unicode.len(self.text) end end }, checkbox = { x = 1, y = 1, w = 4, h = 3, active_color = 0xcccccc, active = false, bgcolor = 0x000000, fgcolor = 0xffffff, render = function(self) twins.container.setForeground(self.fgcolor) twins.container.setBackground(self.bgcolor) twins.draw_frame(self) if self.active then twins.container.setBackground(self.active_color) end twins.container.set(self.x+1, self.y+1, \" \") end, onclick = function(self) self.active = not self.active self.render(self) end }, input = { x=1, y=1, w=10, h=2, bgcolor = 0x222222, fgcolor = 0xffffff, cursor = 1, view = 1, blinker_t = \"not_init\", blinker_state = 0, allowed_chars = \"\", text=\"\", password=false, creation_ctx = -1, max_length = math.huge, render = function(self) while self.cursor-self.view > self.w-1 do self.view = self.view + 1 end if self.cursor-self.view < 0 then self.view = self.cursor end if self.view < 1 then self.view = 1 end twins.container.setBackground(self.bgcolor) twins.container.setForeground(self.fgcolor) twins.container.set(self.x, self.y+self.h-1, string.rep(\"─\", self.w)) local text = unicode.sub(tostring(self.text), self.view, self.view+self.w-1) if self.password then text = string.rep(\"*\", unicode.len(text)) end text = text .. string.rep(\" \", self.w - unicode.len(text)) twins.container.set(self.x, self.y, text) end, draw_cursor = function(self) self.blinker_state = (self.blinker_state + 1) % 2 local glob_cur_pos = self.cursor-self.view+self.x if self.blinker_state == 0 then local cur_char = twins.container.get(glob_cur_pos, self.y) twins.container.setBackground(self.bgcolor) twins.container.setForeground(self.fgcolor) twins.container.set(glob_cur_pos, self.y, cur_char) else if twins.focus == self._id then local cur_char = twins.container.get(glob_cur_pos, self.y) twins.container.setBackground(self.fgcolor) twins.container.setForeground(self.bgcolor) twins.container.set(glob_cur_pos, self.y, cur_char) end end end, onclick = function(self) if self.cursor > unicode.len(self.text) + 1 then self.cursor = unicode.len(self.text) + 1 end if self.cursor < 1 then self.cursor = 1 end self.draw_cursor(self) end, oncreate = function(self) self.creation_ctx = twins.active_context self.blinker_t = event.timer(0.5, function() if twins.active_context == self.creation_ctx then self:draw_cursor() end end, math.huge) self.cursor = unicode.len(self.text) + 1 end, ondestroy = function(self) event.cancel(self.blinker_t) end, ovr_lets = { [8] = function(self, let, key) if self.cursor > 1 then self.text = unicode.sub(self.text, 1, self.cursor-2) .. unicode.sub(self.text, self.cursor, unicode.len(self.text)) self.cursor = self.cursor - 1 if self.cursor < 1 then self.cursor = 1 end if self.cursor-self.view < 2 then self.view = self.cursor - 2 end self.render(self) end end, [13] = function(self, let, key) if self.onconfirm then self.onconfirm(self) end end, [127] = function(self, let, key) self.text = unicode.sub(self.text, 1, self.cursor-1) .. unicode.sub(self.text, self.cursor+1, unicode.len(self.text)) self.render(self) end }, ovr_keys = { [203] = function(self, let, key) self.cursor = self.cursor - 1 if self.cursor < 1 then self.cursor = 1 end self.render(self) end, [205] = function(self, let, key) self.cursor = self.cursor + 1 if self.cursor > unicode.len(self.text) + 1 then self.cursor = unicode.len(self.text) + 1 end self.render(self) end }, typechar = function(self, let, key) if unicode.len(self.text) < self.max_length then self.text = (unicode.sub(self.text, 1, self.cursor-1) .. unicode.char(let) .. unicode.sub(self.text, self.cursor, unicode.len(self.text)) ) self.cursor = self.cursor + 1 self.render(self) if self.onmodify then self.onmodify(self) end end end, onkeydown = function(self, let, key) if self.ovr_lets[let] then self.ovr_lets[let](self, let, key) if self.onmodify then self.onmodify(self) end elseif self.ovr_keys[key] then self.ovr_keys[key](self, let, key) if self.onmodify then self.onmodify(self) end else if let > 31 then if self.allowed_chars:len() == 0 or self.allowed_chars:find(string.char(let)) then self.typechar(self, let, key) end end end if self.cursor < 1 then self.cursor = 1 end self.blinker_state = 0 self.draw_cursor(self) end }, frame = { x = 1, y = 1, w = 10, h = 10, bgcolor = 0x000000, fgcolor = 0xffffff, render = function(self) twins.container.setBackground(self.bgcolor) twins.container.setForeground(self.fgcolor) twins.draw_frame(self) end }, list = { x = 1, y = 1, w = 10, h = 10, bgcolor = 0x000000, fgcolor = 0xffffff, sel_color = 0x666666, selection = -1, items = {}, scroll_size = 3, scroll = 0, get_value = function(self) return self.items[self.selection] end, render = function(self) twins.container.setBackground(self.bgcolor) twins.container.setForeground(self.fgcolor) local line = 0 if self.scroll > 0 then twins.container.set(self.x, self.y+line, \"...\"..(\" \"):rep(self.w-3)) line = line + 1 end for k=self.scroll+1, #self.items do local i = self.items[k] local wspace = (\" \"):rep(self.w-unicode.len(i)) if self.selection-self.scroll == line+1 then twins.container.setBackground(self.sel_color) twins.container.set(self.x, self.y+line, tostring(i)..wspace) twins.container.setBackground(self.bgcolor) else twins.container.set(self.x, self.y+line, tostring(i)..wspace) end line = line + 1 if line == self.h then twins.container.set(self.x, self.y+line-1, \"...\"..(\" \"):rep(self.w-3)) return end end local wspace = (\" \"):rep(self.w) for i=line, self.h-1 do twins.container.set(self.x, self.y+i, wspace) end end, onclick = function(self, pabs, prel, button) if prel.y+self.scroll+1 <= #self.items+1 then self.selection = prel.y+self.scroll+1 if self.onmodify then self.onmodify(self) end end self.render(self) end, onscroll = function(self, pabs, prel, size) self.scroll = self.scroll - size*self.scroll_size if self.scroll > #self.items-self.scroll_size then self.scroll = #self.items-self.scroll_size end if self.scroll < 0 then self.scroll = 0 end self.render(self) end }, group = { x = 1, y = 1, w = 10, h = 0, bgcolor = 0x000000, fgcolor = 0xffffff, clickable = false, visible = false, linked_frame = nil, framed = false, gap = 1, direction = \"horizontal\", items={}, padding = {left=0, right=0, up=0, down=0}, calculate_positions = function(self) if self.direction == \"horizontal\" or self.direction == \"h\" then local dx = self.padding.left local h_max = 0 for k, v in ipairs(self.items) do assert(type(v) == \"table\", \"[\"..k..\"] не является элементом.\") v.y = self.y + (v.off_y or 0) + self.padding.up v.x = self.x + dx + (v.off_x or 0) if v.calculate_positions then v:calculate_positions() end h_max = math.max(h_max, v.h) dx = dx + v.w + self.gap end self.w = dx - self.gap + self.padding.right self.h = h_max + self.padding.down + self.padding.up elseif self.direction == \"vertical\" or self.direction == \"v\" then local dy = self.padding.up local w_max = 0 for k, v in ipairs(self.items) do assert(type(v) == \"table\", \"[\"..k..\"] не является элементом.\") v.y = self.y + dy + (v.off_y or 0) v.x = self.x + self.padding.right + (v.off_x or 0) if v.calculate_positions then v:calculate_positions() end w_max = math.max(w_max, v.w) dy = dy + v.h + self.gap end self.w = w_max + self.padding.right + self.padding.left self.h = dy - self.gap + self.padding.down end if self.linked_frame then self.linked_frame.x = self.x self.linked_frame.y = self.y self.linked_frame.w = self.w self.linked_frame.h = self.h end end, oncreate = function(self) if self.framed then self.padding = {left=1, right=1, up=1, down=1} end self:calculate_positions() if self.align then twins.sps.position(self.align, self) self:calculate_positions() end if self.framed and self.linked_frame == nil then self.linked_frame = twins.base.frame({ x=self.x, y=self.y, w=self.w, h=self.h, fgcolor=self.fgcolor, bgcolor=self.bgcolor, clickable=false }) end end }, radio_button = { x = 1, y = 1, w = 10, h = 3, bgcolor = 0x222222, active_bgcolor = 0x666666, active_fgcolor = 0xffffff, fgcolor = 0xffffff, active = false, radio_channel = 1, text = \"button\", set_channel = function(self, channel) local channel_arr = twins.radio_channel[self.radio_channel] for i = 1, #channel_arr do if channel_arr[i] == self then table.remove(channel_arr, i) end end self.radio_channel = channel self:oncreate() end, render = function(self) if self.active then twins.container.setBackground(self.active_bgcolor) twins.container.setForeground(self.active_fgcolor) else twins.container.setBackground(self.bgcolor) twins.container.setForeground(self.fgcolor) end twins.container.fill(self.x, self.y, self.w, self.h, \" \") twins.draw_frame(self) twins.container.set(self.x+self.w/2-unicode.len(self.text)/2, self.y+self.h/2, self.text) end, oncreate = function(self) twins.radio_channel = twins.radio_channel or {} if twins.radio_channel[self.radio_channel] == nil then twins.radio_channel[self.radio_channel] = {self} else table.insert(twins.radio_channel[self.radio_channel], self) end end, onclick = function(self) local channel = twins.radio_channel[self.radio_channel] for k, v in ipairs(channel) do if v.active then v.active = false v:render() end end self.active = true if self.onselected then self:onselected() end self:render() end, ondestroy = function(self) local channel = twins.radio_channel[self.radio_channel] for k, v in ipairs(channel) do if v == self then table.remove(channel, k) break end end end }, spacing = { visible = false, clickable = false, w = 1, h = 1 } } return elem_base",["/lib/twins/core/sps.lua"]="local sps = {} function sps.center(e, mode) local cx = math.floor((twins.sem.scw-e.w)/2) local cy = math.floor((twins.sem.sch-e.h)/2) if mode == \'x\' then e.x = cx elseif mode == \'y\' then e.y = cy else e.x = cx e.y = cy end if e.calculate_positions then e:calculate_positions() end return e, {x=cx, y=cy} end function sps.right(e) local rx = twins.sem.scw-e.w-1 e.x = rx if e.calculate_positions then e:calculate_positions() end return e, rx end function sps.left(e) local lx = 1 e.x = lx if e.calculate_positions then e:calculate_positions() end return e, lx end function sps.up(e) local uy = 1 e.y = uy if e.calculate_positions then e:calculate_positions() end return e, uy end function sps.down(e) local dy = twins.sem.sch-e.h e.y = dy if e.calculate_positions then e:calculate_positions() end return e, dy end local function pos_list(list, dir, fun) dir = dir or \"down\" if dir == \"down\" then local ly = 1 for k, e in pairs(list) do fun(e) e.y = ly ly = ly + e.h if e.calculate_positions then e:calculate_positions() end end else local ly = twins.sem.sch for k, e in pairs(list) do ly = ly - e.h fun(e) e.y = ly if e.calculate_positions then e:calculate_positions() end end end return list end function sps.right_list(list, dir) return pos_list(list, dir, sps.right) end function sps.left_list(list, dir) return pos_list(list, dir, sps.left) end function sps.center_list(list, dir) return pos_list(list, dir, sps.center) end function sps.position(attr, e) for fun in attr:gmatch(\"[%w_]+\") do if type(sps[fun]) == \"function\" then sps[fun](e) end end if e.calculate_positions then e:calculate_positions() end return e end return sps",["/lib/twins/core/sem.lua"]="local sem = {} sem.document = nil sem.elements = nil sem.named_elements = nil sem.focus = -1 sem.element_templates = nil sem.contexts = {} sem.active_context = 1 function sem.invoke(element, method, ...) if not element then error(debug.traceback()) end if type(element[method]) == \"function\" then element[method](element, ...) end end function sem.add_element(element) for i=1, #sem.elements+1 do if sem.elements[i] == nil then element = setmetatable({ internal=element, render=element.render, getxywh = function(t) return rawget(t.internal, \"x\"), rawget(t.internal, \"y\"), rawget(t.internal, \"w\"), rawget(t.internal, \"h\") end }, { __index = function(t, i) rawset(t, \"changed\", true) return rawget(t.internal, i) end, __newindex = function(t, i, v) rawset(t, \"changed\", true) rawset(t.internal, i, v) end, __pairs = function(t) return pairs(rawget(t, \"internal\")) end, __ipairs = function(t) return ipairs(rawget(t, \"internal\")) end }) sem.elements[i] = element sem.elements[i]._id = i if sem.elements[i].clickable == nil then sem.elements[i].clickable = true end if sem.elements[i].visible == nil then sem.elements[i].visible = true end sem.invoke(sem.elements[i], \"oncreate\") return sem.elements[i] end end end function sem.get_element_by_key(key) return sem.named_elements[key] end function sem.get_focus() return twins.sem.elements[twins.sem.focus] end local function intersects(a, b) return (a.x < (b.x + b.w)) and (b.x < (a.x + a.w)) and (a.y < (b.y + b.h)) and (b.y < (a.y + a.h)) end local function findCoverage(element, output) for k, v in pairs(element._covered_by) do output[v] = true findCoverage(v, output) end end function sem.render(force) if type(force) == \"table\" then local affected = {} for k, v in pairs(twins.sem.elements) do end else twins.clear_screen() for k, v in pairs(twins.sem.elements) do if rawget(v, \"changed\") or force then twins.sem.invoke(v, \"render\", true) rawset(v, \"changed\", false) end end twins.container.render() end if twins.sem.document.title then twins.title(twins.sem.document.title) end end function sem.title(title) twins.container.set(3, 1, \"[\"..title..\"]\") end return sem",["/lib/twins/core/util.lua"]="local util = {} function util.deep_copy(t) if type(t) ~= \"table\" then return t end local new_t = {} for k, v in pairs(t) do new_t[k] = util.deep_copy(v) end return new_t end return util",["/lib/twins/core/elements_helper.lua"]="local sem = require(\"twins.core.sem\") local util = require(\"twins.core.util\") local api = {} local function apply_class(element, classname) local class_props = sem.element_templates[classname] for k, v in pairs(class_props) do if not element[k] then element[k] = util.deep_copy(v) end end end function api.add_template(name, template, parent) if not parent then parent = \"*\" end if type(twins.sem.element_templates[parent]) == \"table\" then for k, v in pairs(twins.sem.element_templates[parent]) do if template[k] == nil then template[k] = util.deep_copy(v) end end end twins.element_templates[name] = template end function api.build_element(element, template) if element.class ~= nil and sem.element_templates[element.class] then apply_class(element, element.class) elseif sem.element_templates[\"*\"] then apply_class(element, \"*\") end for k, v in pairs(template) do if not element[k] then element[k] = util.deep_copy(v) end end local prepared_element = sem.add_element(element) if element.key ~= nil then assert( sem.named_elements[prepared_element.key] == nil, \"Ошибка при создании элемента с ключом: \\\"\"..prepared_element.key .. \"\\\" уже существует\" ) sem.named_elements[prepared_element.key] = prepared_element end prepared_element.render = wrapped_render prepared_element._covered_by = {} return prepared_element end function api.clear_elements() twins.sem.elements = {} twins.sem.named_elements = {} end return api",["/lib/twins/core/graphics_helper.lua"]="local api = {} function api.clear_screen(color) twins.container.setForeground(twins.sem.document.fgcolor or 0xffffff) twins.container.setBackground(color or twins.sem.document.bgcolor or 0x000000) twins.container.fill(1, 1, twins.sem.scw, twins.sem.sch, \" \") end function api.draw_frame(elem) local vl = (\"│\"):rep(elem.h-2) local hl = (\"─\"):rep(elem.w-2) twins.container.set(elem.x, elem.y, \"┌\"..vl..\"└\", true) twins.container.set(elem.x+elem.w-1, elem.y, \"┐\"..vl..\"┘\", true) twins.container.set(elem.x+1, elem.y, hl) twins.container.set(elem.x+1, elem.y+elem.h-1, hl) end return api"}

for k, v in pairs(pkg) do
    local dir = fs.path(k)
    if (not fs.isDirectory(dir)) or (not fs.exists(dir)) then
        print("Создание папки: "..dir)
        fs.makeDirectory(dir)
    end
    print("Распаковка: "..k)
    local f, e = io.open(k, "w")
    if not f then error(e) end
    f:write(v)
    f:flush()
    f:close()
end
